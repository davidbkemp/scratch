<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<title>An Interactive Introduction To Quantum Computing Part 2</title>
<link rel="stylesheet" href="qtalk.css" />
</head>

<body>
<section>
    <h1>An Interactive Introduction To Quantum Computing Part 2</h1>
    <p>
        This is Part 2 of a two part series.
        In <a href="index.html">Part 1</a>
        I explained some of the basics of what a qubit is
        including the mysterious notions of phase and quantum interference.
        Here in Part 2, you will get to see a very simple quantum algorithm.
    </p>
    <p>DRAFT</p>
</section>


<section>
<h1>Multiple qubits</h1>
<p>
    <b>Important</b>: There is something really important I feel the need to emphasize
    as we start dealing with multiple qubits.
</p>
<p>The blue disks introduced in Part 1 do <em>not</em> correspond to single qubits.</p>
<p>
    <b>Each blue disk corresponds to a distinct state of the entire quantum system.</b>
    If you are not sure what I mean by that,
    then please hang in there,
    it will hopefully become aparent very soon.
    <span class="help">
    The blue disks are technically called quantum state &ldquo;amplitudes&rdquo;.
    </span>
</p>
</section>

<section>
<h1>Controlled NOT</h1>
<p>
    The <em>Controlled NOT</em> operator is a very simple but powerful
    two-qubit operator.
</p>
<p>
    The Controlled NOT operator modifies the state of one qubit (the target qubit)
    based on the state of another qubit (the control qubit).
</p>
<p>
    Specifically, <b>the Controlled NOT operator flips the value of the target qubit
    if the control qubit has a value of 1.</b>
</p>
<p>
    For example:
    Suppose we have two qubits with
    an initial state of &ldquo;11&rdquo;.
    Let&apos;s use the left qubit as the control qubit
    and the right qubit as the target.
    Then the result of applying a Controlled NOT
    will be &ldquo;10&rdquo;.
    As usual, we represent this as
    &ldquo;11 &rarr; 10&rdquo;
</p>
<p>
    Continuing with our choice of left qubit as control qubit
    and right qubit as target,
    there are four scenarios to consider for
    the Controlled NOT operator.
</p>
<ul>
    <li>00 &rarr; 00 (i.e. no effect)</li>
    <li>01 &rarr; 01 (i.e. no effect)</li>
    <li>10 &rarr; 11 (i.e. target bit flips)</li>
    <li>11 &rarr; 10 (i.e. target bit flips)</li>
</ul>
</section>

<section>
    <h1>Quantum Entanglement</h1>
    <p>
        A combination of the Hadamard followed by a Controlled NOT
        can put two qubits into a state of &ldquo;quantum entanglement&rdquo;.
    </p>
    <p>
        In what follows, we take a two qubit system in the state &quot;00&quot;,
        apply the Hadamard operation to the left qubit,
        and then use that left qubit as the control in a Controlled NOT
        of the right qubit:
    </p>
    <h2>Initial State</h2>
    <div class="animationBlock" id="cnot-0">
        <div class="qstate">State: <span class="qstateValue"></span></div>
        <svg class="qstateSvg qstateSvg__hideBitLabels"></svg>
    </div>
    
    <h2>After applying a Hadamard to the left qubit</h2>
    <div class="animationBlock" id="cnot-1">
        <div class="qstate">State: <span class="qstateValue"></span></div>
        <svg class="qstateSvg qstateSvg__hideBitLabels"></svg>
    </div>
    <h2>After a Controlled NOT of the right qubit controlled by the left qubit</h2>
    <div class="animationBlock" id="cnot-2">
        <div class="qstate">State: <span class="qstateValue"></span></div>
        <svg class="qstateSvg qstateSvg__hideBitLabels"></svg>
    </div>
    <p>
        Note that, if you were to measure the qubits while they are in this state,
        you would find that they are either both 0 or both 1.
    </p>
</section>

<section>
    <h1>Toffoli</h1>
    <p>
        The Toffoli Operator is a just like the Controlled NOT,
        only it uses two control qubits instead of one.
        The target qubit is flipped if and only if
        both of the control bits are 1&apos;s.
    </p>
    <p>
        For example: If the initial state is &quot;111&quot;,
        and if the two left qubits are used as the control qubits,
        and the right qubit is the target,
        then the result will be &quot;110&quot;.
        As usual, we represent this as
        &ldquo;111 &rarr; 110&rdquo;
    </p>
<p>
    Continuing with our choice of the two left qubits as control qubits
    and right qubit as target,
    there are eight scenarios to consider for
    the Toffoli operator.
</p>
<ul>
    <li>000 &rarr; 000 (i.e. no effect)</li>
    <li>001 &rarr; 001 (i.e. no effect)</li>
    <li>010 &rarr; 010 (i.e. no effect)</li>
    <li>011 &rarr; 011 (i.e. no effect)</li>
    <li>010 &rarr; 010 (i.e. no effect)</li>
    <li>101 &rarr; 101 (i.e. no effect)</li>
    <li>110 &rarr; 111 (i.e. target bit flips)</li>
    <li>111 &rarr; 110 (i.e. target bit flips)</li>
</ul>
</section>

<section>
    <h1>Toffoli (Your Turn)</h1>
    <p>
        See how the Toffoli affects a superpostion of all possible states:
    </p>
    <div class="animationBlock" id="ToffoliExample">
        <div class="animationBlock_buttons">
            <div>
                <button class="operator" data-operator="cnot"
                    data-control-qubits="1,2" data-qubits="0"
                    data-skipInterferenceSteps>Apply Toffoli</button>
            </div>
        </div>
        <svg class="qstateSvg qstateSvg__hideBitLabels"></svg>
    </div>
</section>

<section>
    <h1>Arbitrary Boolean Functions</h1>
    <p>
        In addition to the NOT operator that we have already seen,
        a quantum computer can implement the standard
        boolean functions of AND and OR.
        <span class="help">
            <span class="math"> x AND y</span> is 1 if and only if
            both x and y are 1.
            <span class="math"> x OR y</span> is 1 if either or both
            of x or y are 1.
        </span>
    </p>
    <p>But there is a catch.</p>
    <p>
        <b>Quantum operators must be reversible</b>
        (except for the measurement operator):
        i.e. you must be able to derive the input state from the output state.
        This is a fundamental consequence of how quantum mechanics works.
    </p>
    <p>
        The conventional implementations of AND and OR
        set the output bit to the result of the operation.
        The problem with this is that you lose
        the original value of the output bit
        and there is no guaranteed way of
        using the result
        to derive what its original value was.
    </p>
    <p>
        Reversible versions of AND and OR
        are obtained by leaving the input bits unchanged,
        using a separate (third) bit as the output bit and,
        instead of setting the output bit to the result,
        you conditionally flip the value of the output bit
        based on whether or not the result of the operation is a 1.
        E.g.
        <b>
            the Toffoli operation is
            the way we implement the AND operation
            in a quantum computer.
        </b>
    </p>
    <p>
        The OR operator can be implemented using combinations of
        the AND and NOT operators since
    </p>
    <p>x OR y  = NOT (NOT x AND NOT y)</p>
    <p>
        Using the AND, OR, and NOT operators,
        it is possible to implement any arbitrary
        boolean function that has a fixed number of input and output bits.
    </p>
    <p>
        The key trick with quantum computers is that the output bits
        are usually a seperate collection of bits to the input bits and,
        instead of setting the output bits to specific values,
        their existing values (whatever they were)
        are either flipped or left as they are
        depending on whether the operation result
        is supposed to be a 1 or a 0 respectively.
    </p>
</section>

<section>
<h1>Simple 1-Bit Functions</h1>
<p>
    I am about to describe
    a really simple quantum computation algorithm,
    but first we need to explore the four different
    classical 1-bit functions and how we might implement them
    in a quantum computer.
</p>
<p>
    There are only four possible one bit functions
    <span class="math">y=f(x)</span>
    where x and y are single bit values:
</p>
<ul>
    <li>f(x) = x</li>
    <li>f(x) = NOT(x)</li>
    <li>f(x) = 0</li>
    <li>f(x) = 1</li>
</ul>

<p>
    Hopefully it is pretty obvious how you would implement these,
    but I will spell it out anyway.
</p>
    <p>
        Recall that,
        by applying <span class="math">f</span>,
        we mean that the output bit is flipped from its initial value
        if and only if the application of <span class="math">f</span>
        to the input value is 1.
        So, for example, if
        <span class="math">f(x) = x</span>
        and if the initial state of the qubits was &ldquo;11&rdquo;
        then the result would be &ldquo;10&rdquo;.
    </p>
<ul>
    <li>f(x) = x : Flip the output bit if the input is 1 (ie. a Controlled NOT)</li>
    <li>f(x) = NOT(x) : Controlled NOT followed by a NOT</li>
    <li>f(x) = 0 : Do nothing</li>
    <li>f(x) = 1 : Flip the output bit regardless of the input.</li>
</ul>
</section>

<section>
    <h1>Simple 1-Bit Functions (Your Turn)</h1>
    <p>
        Try out each of the 1-bit functions on
        a superposition of all states.
    </p>
    <p>
        In the interactive example below,
        the left qubit is the input bit (x),
        and the right qubit is the output bit f(x)
        -- but don&apos;t forget, we are flipping bits instead of setting them!
    </p>
    <div class="animationBlock" id="1bitFunctions">
        <div class="animationBlock_buttons">
            <button class="operator" data-operator="cnot"
                data-control-qubits="1"
                data-qubits="0">f(x)=x</button>
            <button class="operator" data-operator="notCNot"
                data-control-qubits="1"
                data-qubits="0">f(x)=NOT(x)</button>
            <button class="operator"
                data-operator="nop">f(x)=0</button>
            <button class="operator" data-operator="not"
                data-qubits="0">f(x)=1</button>
        </div>
        <svg class="qstateSvg qstateSvg__hideBitLabels"></svg>
    </div>
</section>

<section>
    <h1>Deutche&apos;s Algorithm</h1>
    <p>
        Possibly the simplest quantum computing algorithm is Deutche&apos;s Algorithm.
    </p>
    <p>
        Imagine you are provided with a piece of circuitry that
        implements one of
        the four possible 1-bit functions
        <span class="math">f</span>
        just described,
        but you have not been told which one of the four it is.
    </p>
    
    <p>
        Your task is to compute
        <span class="math">f(0) XOR f(1)</span>,
        where
        <span class="math">x XOR y</span> is 1 if only one of x or y are 1, but not both.
        I.e.
    </p>
    <ul>
        <li><span class="math">0 XOR 0 = 0</span></li>
        <li><span class="math">0 XOR 1 = 1</span></li>
        <li><span class="math">1 XOR 0 = 1</span></li>
        <li><span class="math">1 XOR 1 = 0</span></li>
    </ul>
    <p>
        For example, if <span class="math">f(x) = x</span>,
        then <span class="math">f(0) XOR f(1) = 0 XOR 1 = 1</span>.
    </p>
    <p>
        There are four possibilities:
    </p>
    <ul>
        <li>
            <b>If</b> <span class="math">f(x) = x</span>
            <b>then</b> <span class="math">f(0) XOR f(1) = 0 XOR 1 = 1</span>
        </li>
        <li>
            <b>If</b> <span class="math">f(x) = NOT(x)</span>
            <b>then</b> <span class="math">f(0) XOR f(1) = 1 XOR 0 = 1</span>
        </li>
        <li>
            <b>If</b> <span class="math">f(x) = 0</span>
            <b>then</b> <span class="math">f(0) XOR f(1) = 0 XOR 0 = 0</span>
        </li>
        <li>
            <b>If</b> <span class="math">f(x) = 1</span>
            <b>then</b> <span class="math">f(0) XOR f(1) = 1 XOR 1 = 0</span>
        </li>
    </ul>
    <p>
        The obvious approach is to compute both
        <span class="math">f(0)</span>
        and
        <span class="math">f(1)</span>
        and then compute the XOR of those two results.
        Indeed,
        <b>
            conventional computers cannot compute
            <span class="math">f(0) XOR f(1)</span>
            without computing values for both
            <span class="math">f(0)</span>
            and
            <span class="math">f(1)</span>.
        </b>
    </p>
    <p>
        If <span class="math">f</span>
        is implemented on a quantum computer, then
        <b>
            Deutche&apos;s Algorithm allows you to compute
            <span class="math">f(0) XOR f(1)</span>
            with only a single invocation of
            <span class="math">f</span>.
        </b>
    </p>
    <p>
        As you will see,
        Deutche&apos;s Algorithm
        achieves this by applying
        <span class="math">f</span>
        to a superposition of 0 and 1,
        and using quantum interference to find
        <span class="math">f(0) XOR f(1)</span>.
    </p>
</section>

<section>
    <h1>Implementing Deutche&apos;s Algorithm</h1>
    <p>
        To implement Deutche&apos;s Algorithm we need two qubits.
        We designate one qubit (the left one) the input qubit
        and the other (the right one) the output qubit.
    </p>
    <p>
        Here are the steps:
    </p>
    <ol>
        <li>
            Start with the qubits in a superposition of all possible states:
            00, 01, 10, and 11.
        </li>
        <li>Apply the unknown function <span class="math">f</span> once only.</li>
        <li>Apply a Hadamard to the input qubit.</li>
        <li>Measure.</li>
    </ol>

    <p>
        There are a couple of important details that I have left out.
    </p>
    <p>
        For staters,
        the initial state cannot be any old superposition of all possible states.
        It has to be this one:
        <span class="help">
            Actually, any superposition that has the same <em>relative</em>
            phases will also work.
            This particular superposition
            can be created by applying Hadamards to the state &ldquo;01&rdquo;.
        </span>
    </p>
    <div class="animationBlock" id="DeutchInitialState">
        <svg class="qstateSvg qstateSvg__hideBitLabels"></svg>
    </div>
    <p>
        The other important detail is that the desired result,
        <span class="math">f(0) XOR f(1)</span>,
        is obtained by measuring the <em>input</em> qubit.
        No, that is not a clumsy mistake I just made,
        the desired result will be the value of the input qubit,
        not the output qubit.
    </p>
    <p>
        Try it yourself. Select one of the four fuctions,
        and then Hadamard the input qubit.
    </p>
     <p>
        Once again, the left qubit is the input to f and
        the right qubit is flipped if <span class="math">f(x) = 1</span>.
    </p>
    <p>
        Notice how the interfence results in
        the four different states combining
        to produce just two states,
        both of which are either at the top
        (&ldquo;00&rdquo; and &ldquo;01&rdquo;)
        or at the bottom
        (&ldquo;10&rdquo; and &ldquo;11&rdquo;).
    </p>
    <p>
        If both states are at the top
        then the input bit is guaranteed to be 0,
        and this implies that
        <span class="math">f(0) XOR f(1) = 0</span>
        If they are both at the bottom
        then the input bit is guaranteed to be 1,
        and this implies that
        <span class="math">f(0) XOR f(1) = 0</span>.
        The output bit can be safely ignored.
    </p>
    <div class="animationBlock" id="DeutchExample">
        <div class="animationBlock_buttons">
            <div>
                <div data-step="1">
                    <button class="operator" data-operator="cnot"
                        data-control-qubits="1"
                        data-qubits="0">f(x)=x</button>
                    <button class="operator" data-operator="notCNot"
                        data-control-qubits="1"
                        data-qubits="0">f(x)=NOT(x)</button>
                    <button class="operator"
                        data-operator="nop">f(x)=0</button>
                    <button class="operator" data-operator="not"
                        data-qubits="0">f(x)=1</button>
                </div>
                
                <div>
                    <button class="operator" data-operator="hadamard"
                        data-qubits="1" data-step="2">Hadamard Input Bit</button>
                        
                    <button class="measure"
                        data-qubits="0,1" data-step="3">Measure</button>
                        
                    <button class="reset" data-step="4">Reset</button>
                </div>
            </div>
        </div>
        <svg class="qstateSvg qstateSvg__hideBitLabels"></svg>
    </div>
</section>

<section>
    <h1>What&apos;s All The Fuss About</h1>
    <p>
        
    </p>
</section>

<section>
<h1>Some philosophy</h1>
</section>

<section>
<h1>Some maths</h1>
</section>

<section>
<h1>Useful links</h1>
</section>

<footer>
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by/4.0/80x15.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">An Interactive Introduction To Quantum Computing</span> by <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">David Kemp</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/deed.en_US">Creative Commons Attribution 4.0 International License</a>.</footer>

<script src="http://code.jquery.com/jquery-2.1.0.js"></script>
<script src="dist/main.js"></script>
<script src="browserSupportDetection.js"></script>

</body>
</html>